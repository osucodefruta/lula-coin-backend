<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Damas 3D - Online</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #game-container { width: 100vw; height: 100vh; }
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; text-shadow: 0 0 5px black; }
        #turn-indicator { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); padding: 10px 20px; background-color: rgba(0, 0, 0, 0.5); border-radius: 10px; font-size: 1.2em; font-weight: bold; }
        .scoreboard { position: absolute; top: 20px; padding: 10px 15px; background-color: rgba(0, 0, 0, 0.5); border-radius: 8px; font-size: 1.5em; font-weight: bold; }
        #score-player1 { left: 20px; }
        #score-player2 { right: 20px; }
        #emoji-bar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; padding: 10px; background-color: rgba(0, 0, 0, 0.5); border-radius: 50px; pointer-events: auto; }
        .emoji-button { font-size: 2em; cursor: pointer; transition: transform 0.2s, opacity 0.3s; }
        .emoji-button:hover { transform: scale(1.2); }
        .floating-emoji { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 10em; opacity: 0; animation: float-in-out 2s forwards; text-shadow: 0 0 15px rgba(0,0,0,0.7); }
        @keyframes float-in-out {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            25% { transform: translate(-50%, -55%) scale(1.1); opacity: 1; }
            75% { transform: translate(-50%, -60%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -70%) scale(0.5); opacity: 0; }
        }
        #winner-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; flex-direction: column; text-align: center; font-size: 2em; pointer-events: auto; z-index: 200; }
        #winner-screen h2 { font-size: 2em; color: #FFD700; }
        #back-to-lobby-btn { padding: 15px 30px; font-size: 0.8em; cursor: pointer; border-radius: 5px; border: none; background-color: #00ff7f; color: #1a1a1a; font-weight: bold; margin-top: 20px; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="ui-container">
        <div id="score-player1" class="scoreboard">Player 1: <span id="p1-score">0</span></div>
        <div id="score-player2" class="scoreboard">Player 2: <span id="p2-score">0</span></div>
        <div id="turn-indicator">Aguardando...</div>
        <div id="emoji-bar">
            <span class="emoji-button" data-emoji="üòä">üòä</span>
            <span class="emoji-button" data-emoji="üò¢">üò¢</span>
            <span class="emoji-button" data-emoji="üëç">üëç</span>
            <span class="emoji-button" data-emoji="üëã">üëã</span>
            <span class="emoji-button" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</span>
        </div>
        <div id="winner-screen">
            <h2 id="winner-player"></h2>
            <button id="back-to-lobby-btn">Voltar ao Lobby</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Este bloco cont√©m a l√≥gica PURA do jogo de damas (validar jogadas, etc)
        // Ele n√£o interage com a UI ou com a rede diretamente.
        const LocalGameLogic = {
            isValidMove: function(board, from, to, player, isKing) {
                if (board[to.row][to.col] !== 0) return { valid: false };
                const moveDir = player === 1 ? -1 : 1;
                const dr = to.row - from.row;
                const dc = to.col - from.col;

                if (!isKing) {
                    if (Math.abs(dc) === 1 && dr === moveDir) return { valid: true, type: 'move' };
                    if (Math.abs(dc) === 2 && dr === moveDir * 2) {
                        const capturedRow = from.row + moveDir; const capturedCol = from.col + dc / 2;
                        const capturedPiece = board[capturedRow][capturedCol];
                        if (capturedPiece !== 0 && (capturedPiece % 2 !== player % 2)) {
                            return { valid: true, type: 'capture', captured: { row: capturedRow, col: capturedCol } };
                        }
                    }
                } else {
                    if (Math.abs(dr) !== Math.abs(dc)) return { valid: false };
                    const stepR = Math.sign(dr); const stepC = Math.sign(dc); let capturedPiece = null; let capturedCount = 0;
                    for (let i = 1; i < Math.abs(dr); i++) {
                        const r = from.row + i * stepR; const c = from.col + i * stepC;
                        const pieceOnPath = board[r][c];
                        if (pieceOnPath !== 0) {
                            if (pieceOnPath % 2 !== player % 2) { capturedPiece = { row: r, col: c }; capturedCount++; } 
                            else { return { valid: false }; }
                        }
                    }
                    if (capturedCount > 1) return { valid: false };
                    if (capturedCount === 1) return { valid: true, type: 'capture', captured: capturedPiece };
                    return { valid: true, type: 'move' };
                }
                return { valid: false };
            },
            canPieceCapture: function(board, fromRow, fromCol) {
                const pieceType = board[fromRow][fromCol]; if (pieceType === 0) return false;
                const isKing = pieceType > 2; const player = (pieceType === 1 || pieceType === 3) ? 1 : 2;
                if (!isKing) {
                    const moveDir = player === 1 ? -1 : 1; const directions = [[moveDir, -1], [moveDir, 1]];
                    for (const [dr, dc] of directions) {
                        const opponentRow = fromRow + dr; const opponentCol = fromCol + dc;
                        const destRow = fromRow + dr * 2; const destCol = fromCol + dc * 2;
                        if (destRow >= 0 && destRow < 8 && destCol >= 0 && destCol < 8) {
                            const capturedPiece = board[opponentRow][opponentCol];
                            if (capturedPiece !== 0 && (capturedPiece % 2 !== player % 2) && board[destRow][destCol] === 0) return true;
                        }
                    }
                } else {
                    const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    for (const [dr, dc] of directions) {
                        for (let i = 1; i < 8; i++) {
                            const r = fromRow + i * dr; const c = fromCol + i * dc;
                            if (r < 0 || r >= 8 || c < 0 || c >= 8) break;
                            const pieceOnPath = board[r][c];
                            if (pieceOnPath !== 0) {
                                if (pieceOnPath % 2 !== player % 2) {
                                    const destRow = r + dr; const destCol = c + dc;
                                    if (destRow >= 0 && destRow < 8 && destCol >= 0 && destCol < 8 && board[destRow][destCol] === 0) return true;
                                }
                                break;
                            }
                        }
                    }
                }
                return false;
            }
        };
    </script>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- 1. CONFIGURA√á√ÉO GERAL E DE CENA ---
            const API_BASE_URL = 'https://lula-coin-backend.onrender.com';
            const SCALE = 2.5;

            // --- ESTADO DO JOGO ONLINE ---
            let onlineState = {
                gameId: null,
                gameStateInterval: null,
                playerColor: null, // 'p1' ou 'p2'
                myTurnNumber: null, // 1 ou 2
                board: [],
                currentTurn: null,
                selectedPiece: null, // {row, col}
                lastEmojiTimestamp: null,
            };

            // --- ELEMENTOS DA UI ---
            const uiContainer = document.getElementById('ui-container');
            const turnIndicator = document.getElementById('turn-indicator');
            const p1ScoreDisplay = document.getElementById('p1-score');
            const p2ScoreDisplay = document.getElementById('p2-score');
            const scorePlayer1Label = document.getElementById('score-player1');
            const scorePlayer2Label = document.getElementById('score-player2');
            const winnerScreen = document.getElementById('winner-screen');
            const winnerPlayer = document.getElementById('winner-player');
            const backToLobbyBtn = document.getElementById('back-to-lobby-btn');

            // --- SETUP DA CENA 3D ---
            const gameContainer = document.getElementById('game-container');
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101010);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            gameContainer.appendChild(renderer.domElement);
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 25, 35);
            camera.lookAt(0, 5, 0);
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableZoom = false; controls.enablePan = false; controls.maxPolarAngle = Math.PI / 2.2; controls.target.set(0, 5, 0);
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(20, 30, 10); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // --- FUN√á√ïES AUXILIARES DE API E L√ìGICA ---
            const apiRequest = async (endpoint, method = 'GET', body = null) => {
                const token = localStorage.getItem('token');
                if (!token) { window.location.href = 'index.html'; return; }
                const options = { method, headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' } };
                if (body) { options.body = JSON.stringify(body); }
                try {
                    const response = await fetch(`${API_BASE_URL}${endpoint}`, options);
                    if (!response.ok) throw new Error('Erro de rede');
                    return response.json();
                } catch (error) { console.error("Erro de API:", error); return null; }
            };

            function parseJwt(token) { try { return JSON.parse(atob(token.split('.')[1])); } catch (e) { return null; } }

            // --- CRIA√á√ÉO DOS ELEMENTOS 3D ---
            function createPieceTexture(pieceColor, letterColor) { const c = document.createElement('canvas'); c.width=256; c.height=256; const ctx = c.getContext('2d'); ctx.fillStyle=pieceColor; ctx.fillRect(0,0,256,256); ctx.fillStyle=letterColor; ctx.font='bold 180px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('L',128,128); return new THREE.CanvasTexture(c); }
            const pieceGeo = new THREE.CylinderGeometry(0.4 * SCALE, 0.4 * SCALE, 0.15 * SCALE, 32);
            const redMat = new THREE.MeshStandardMaterial({ map: createPieceTexture('#c0392b', '#ecf0f1') });
            const blueMat = new THREE.MeshStandardMaterial({ map: createPieceTexture('#2980b9', '#ecf0f1') });
            const boardGroup = new THREE.Group(); const piecesGroup = new THREE.Group();
            boardGroup.position.y = 8.75; piecesGroup.position.y = 8.75; scene.add(boardGroup, piecesGroup);
            for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { const sqMat = new THREE.MeshStandardMaterial({ color: (r + c) % 2 === 0 ? 0xffffff : 0x000000 }); const sq = new THREE.Mesh(new THREE.BoxGeometry(SCALE, 0.2*SCALE, SCALE), sqMat); sq.position.set((c - 3.5)*SCALE, 0, (r - 3.5)*SCALE); sq.receiveShadow = true; sq.userData = { row: r, col: c, type: 'square' }; boardGroup.add(sq); } }

            // --- FUN√á√ïES DE SINCRONIZA√á√ÉO E UI ---
            function syncSceneWithState() {
                while(piecesGroup.children.length) { piecesGroup.remove(piecesGroup.children[0]); }
                if (!onlineState.board || onlineState.board.length === 0) return;
                for (let row = 0; row < 8; row++) { for (let col = 0; col < 8; col++) {
                    const pieceType = onlineState.board[row][col];
                    if (pieceType === 0) continue;
                    const isKing = pieceType > 2;
                    const player = (pieceType === 1 || pieceType === 3) ? 1 : 2;
                    const pieceMesh = new THREE.Mesh(pieceGeo, player === 1 ? redMat : blueMat);
                    pieceMesh.castShadow = true;
                    pieceMesh.position.set((col - 3.5) * SCALE, 0.2 * SCALE, (row - 3.5) * SCALE);
                    pieceMesh.userData = { row, col, type: 'piece', isKing };
                    piecesGroup.add(pieceMesh);
                    if (isKing) {
                        const ring = new THREE.Mesh(new THREE.RingGeometry(0.45*SCALE, 0.55*SCALE, 32), new THREE.MeshBasicMaterial({color: 0xFFD700, side: THREE.DoubleSide}));
                        ring.rotation.x = -Math.PI / 2; ring.position.y = 0.01;
                        pieceMesh.add(ring); pieceMesh.userData.kingRing = ring;
                    }
                } }
            }
            
            function updateTurnIndicator() {
                if (onlineState.currentTurn === onlineState.myTurnNumber) {
                    turnIndicator.textContent = "√â a sua vez!";
                    turnIndicator.style.backgroundColor = 'rgba(0, 255, 127, 0.7)';
                } else {
                    turnIndicator.textContent = `Aguardando jogada do oponente...`;
                    turnIndicator.style.backgroundColor = 'rgba(255, 165, 0, 0.7)';
                }
            }
            
            function updateScoreboards(players) {
                const p1Data = players.find(p => p.color === 'p1');
                const p2Data = players.find(p => p.color === 'p2');
                let p1Score = 0; let p2Score = 0;
                onlineState.board.forEach(row => row.forEach(cell => {
                    if (cell === 2 || cell === 4) p1Score++;
                    if (cell === 1 || cell === 3) p2Score++;
                }));
                p1Score = 12 - p1Score; p2Score = 12 - p2Score;
                scorePlayer1Label.innerHTML = `${p1Data.username} (Vermelho): <span id="p1-score">${p1Score}</span>`;
                scorePlayer2Label.innerHTML = `${p2Data.username} (Azul): <span id="p2-score">${p2Score}</span>`;
            }

            function showFloatingEmoji(emoji) {
                const emojiDiv = document.createElement('div');
                emojiDiv.className = 'floating-emoji';
                emojiDiv.textContent = emoji;
                uiContainer.appendChild(emojiDiv);
                setTimeout(() => emojiDiv.remove(), 2000);
            }

            // --- L√ìGICA PRINCIPAL DO JOGO ONLINE ---
            async function getGameState() {
                if (!onlineState.gameId) return;
                const state = await apiRequest(`/api/damas/game/state/${onlineState.gameId}`);
                if (state) {
                    let boardChanged = JSON.stringify(onlineState.board) !== JSON.stringify(state.boardState);
                    
                    onlineState.board = state.boardState;
                    onlineState.currentTurn = state.currentTurn;
                    
                    if (!onlineState.playerColor) {
                        const myUserId = parseJwt(localStorage.getItem('token')).user.id;
                        const myPlayerData = state.players.find(p => p.userId === myUserId);
                        onlineState.playerColor = myPlayerData.color;
                        onlineState.myTurnNumber = onlineState.playerColor === 'p1' ? 1 : 2;
                        if(onlineState.myTurnNumber === 1) controls.object.position.set(0, 25, 35); else controls.object.position.set(0, 25, -35);
                        controls.update();
                    }

                    if (boardChanged) syncSceneWithState();
                    updateTurnIndicator();
                    updateScoreboards(state.players);

                    if (state.lastEmoji && state.lastEmoji.timestamp !== onlineState.lastEmojiTimestamp) {
                        onlineState.lastEmojiTimestamp = state.lastEmoji.timestamp;
                        if (state.lastEmoji.sender !== onlineState.playerColor) {
                            showFloatingEmoji(state.lastEmoji.emoji);
                        }
                    }

                    if(state.winner) {
                        clearInterval(onlineState.gameStateInterval);
                        turnIndicator.style.display = 'none'; // Esconde o indicador de turno
                        const winnerUsername = state.players.find(p => p.color === (state.winner === 'p1' ? 'p1' : 'p2')).username;
                        winnerPlayer.textContent = `${winnerUsername} Venceu!`;
                        winnerScreen.style.display = 'flex';
                    }
                }
            }

            async function sendMoveToServer(boardState, nextTurn, winner = null) {
                const body = { boardState, nextTurn, winner };
                await apiRequest(`/api/damas/game/move/${onlineState.gameId}`, 'POST', body);
                getGameState();
            }

            async function sendEmojiToServer(emoji) {
                await apiRequest(`/api/damas/game/emoji/${onlineState.gameId}`, 'POST', { emoji, playerColor: onlineState.playerColor });
            }

            // --- INTERA√á√ÉO ---
            let selectedPieceMesh = null;
            function highlightPiece(pieceMesh, selected) {
                if(selectedPieceMesh) selectedPieceMesh.scale.set(1, 1, 1);
                if(selected && pieceMesh) {
                    pieceMesh.scale.set(1.1, 1.3, 1.1);
                    selectedPieceMesh = pieceMesh;
                } else {
                    selectedPieceMesh = null;
                }
            }

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            function onBoardClick(event) {
                if (winnerScreen.style.display === 'flex') return;
                if (onlineState.currentTurn !== onlineState.myTurnNumber) {
                    console.log("N√£o √© sua vez de jogar.");
                    return;
                }

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([...boardGroup.children, ...piecesGroup.children]);

                if (intersects.length > 0) {
                    const clickedObject = intersects[0].object;
                    const { row, col, type } = clickedObject.userData;

                    if (onlineState.selectedPiece) {
                        if (type === 'square') {
                            const pieceType = onlineState.board[onlineState.selectedPiece.row][onlineState.selectedPiece.col];
                            const isKing = pieceType > 2;
                            const moveInfo = LocalGameLogic.isValidMove(onlineState.board, onlineState.selectedPiece, {row, col}, onlineState.myTurnNumber, isKing);
                            
                            if (moveInfo.valid) {
                                let piece = onlineState.board[onlineState.selectedPiece.row][onlineState.selectedPiece.col];
                                if (piece === 1 && row === 0) piece = 3; if (piece === 2 && row === 7) piece = 4;
                                onlineState.board[row][col] = piece;
                                onlineState.board[onlineState.selectedPiece.row][onlineState.selectedPiece.col] = 0;
                                if (moveInfo.type === 'capture') {
                                    onlineState.board[moveInfo.captured.row][moveInfo.captured.col] = 0;
                                }
                                
                                const canCaptureAgain = moveInfo.type === 'capture' && LocalGameLogic.canPieceCapture(onlineState.board, row, col);

                                if (canCaptureAgain) {
                                    onlineState.selectedPiece = { row, col };
                                    syncSceneWithState();
                                    const newPieceMesh = piecesGroup.children.find(p => p.userData.row === row && p.userData.col === col);
                                    highlightPiece(newPieceMesh, true);
                                } else {
                                    highlightPiece(null, false);
                                    onlineState.selectedPiece = null;
                                    syncSceneWithState();
                                    const p1pieces = onlineState.board.flat().filter(p => p===2 || p===4).length;
                                    const p2pieces = onlineState.board.flat().filter(p => p===1 || p===3).length;
                                    let winner = null;
                                    if(p2pieces === 0) winner = 'p1';
                                    if(p1pieces === 0) winner = 'p2';
                                    sendMoveToServer(onlineState.board, onlineState.myTurnNumber === 1 ? 2 : 1, winner);
                                }
                            } else {
                                onlineState.selectedPiece = null; highlightPiece(null, false);
                            }
                        } else {
                            onlineState.selectedPiece = null; highlightPiece(null, false);
                        }
                    } else if (type === 'piece') {
                        const pieceType = onlineState.board[row][col];
                        const pieceOwner = (pieceType === 1 || pieceType === 3) ? 1 : 2;
                        if (pieceOwner === onlineState.myTurnNumber) {
                            onlineState.selectedPiece = { row, col };
                            highlightPiece(clickedObject, true);
                        }
                    }
                }
            }

            // --- LOOP DE ANIMA√á√ÉO E INICIALIZA√á√ÉO ---
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            // --- INICIALIZA√á√ÉO DO JOGO ONLINE ---
            const urlParams = new URLSearchParams(window.location.search);
            onlineState.gameId = urlParams.get('gameId');

            if (!onlineState.gameId) {
                turnIndicator.textContent = "ERRO: ID da partida n√£o encontrado!";
            } else {
                backToLobbyBtn.addEventListener('click', () => { window.location.href = 'index.html'; });
                document.querySelectorAll('.emoji-button').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Impede que o clique no emoji acione o clique no tabuleiro
                        const emoji = btn.dataset.emoji;
                        showFloatingEmoji(emoji);
                        sendEmojiToServer(emoji);
                    });
                });
                gameContainer.addEventListener('click', onBoardClick);
                
                getGameState();
                onlineState.gameStateInterval = setInterval(getGameState, 3000);
                animate();
            }
        });
    </script>
</body>
</html>
